/* $revision$
 *
 *		      Generate Instruction
 *
 *	This function will actually generate CASM instructions for the
 *	the code. This not written to use the full CASM instruction set
 *	but just the instructions that are generated by the COPLE code.
 *
 *		Copyright (c) 1999 Peter Antoine
 *
 */

#include	<stdio.h>
#include	<stdlib.h>
#include	"cople.h"
#include	"codetree.h"

OPERAND	gen_instr(INST_TYPE instr,OPERAND left, OPERAND right,int address_reg)
{
	extern FILE	*object_file;
	OPERAND	result,op1;
	char	*left_op;
	char	*right_op;
	char	instr_size;
	int	next_address;
	
	/* need to look-up the instruction size.
	 */
	if (left.data_type < 7)
		instr_size = INSTR_SIZE[left.data_type];
	
	/* need to create the return op.
	 * this is by default the left hand operand.
	 */
	result = left;
	

	/* for some strange reason gcc wont accept char[10] as a char*
	 * but what can you do...
	 */
	left_op = calloc(10,sizeof(char));
	right_op = calloc(10,sizeof(char));

	
	/* first things first - must generate any labels
	 * that have been placed and are waiting.
	 */
	gen_labels();

	switch(instr)
	{
	case null:		fprintf(object_file,"\tnop\n");
			break;

	case loop:		fprintf(object_file,"\t%s\td%d,l_%d\n",instr_name[instr],left.reg,right.data);
			break;
	
	case push:		
	case pop:		left_op  = get_op_string(left,address_reg,&next_address,left_op);
			fprintf(object_file,"\t%s.%c\t%s\n",instr_name[instr],instr_size,left_op);
			break;
	
	case call:
	case branch:
	case branch_eq:
	case branch_ne:
	case branch_lt:
	case branch_le:
	case branch_gt:
	case branch_ge:		fprintf(object_file,"\t%s\tl_%d\n",instr_name[instr],left.data);
			break;

	case test:
	case equal:
	case not_eq:
	case less_than:
	case less_equal:
	case greater_than:	/* some data types i.e. strings need a function call to check*/
	case greater_equal:	left_op  = get_op_string(left,address_reg,&next_address,left_op);
			right_op = get_op_string(right,next_address,&next_address,right_op);
			
			if (left.data_type == d_string){
				op1 = get_label();	
				fprintf(object_file,"\tmove.d\ta%d,%s\n",address_reg,left_op);
				fprintf(object_file,"\tmove.d\ta%d,%s\n",address_reg+1,right_op);
				fprintf(object_file,"\txor.d\td%d,d%d\n",left.reg,left.reg);
				fprintf(object_file,"\tmove.w\td%d,a%d(d%d)\n",left.reg+1,address_reg,left.reg);
	
				put_label(op1);
				gen_labels();

				fprintf(object_file,"\ttest.b\ta%d(d%d)+,a%d(d%d)+\n",address_reg+1,left.reg+1,address_reg,left.reg);
				fprintf(object_file,"\tloopne.w\td%d,l_%d\n",left.reg+1,op1.data);
				
				fprintf(object_file,"\t%s\td%d\n",instr_name[instr],left.reg);

			}else if (left.data_type == d_real){
				fprintf(object_file,"\tfsub.f\t%s,%s\n",left_op,right_op);
				fprintf(object_file,"\t%s\td%d\n",instr_name[instr],left.reg);
			}else{
				left_op  = get_op_string(left,address_reg,&next_address,left_op);
				right_op = get_op_string(right,next_address,&next_address,right_op);
				
				fprintf(object_file,"\ttest.%c\t%s,%s\n",instr_size,left_op,right_op);
				fprintf(object_file,"\t%s\td%d\n",instr_name[instr],left.reg);
			};
			
			result.type = o_reg;
			result.data = 0;
			break;

	case add:		/* these can work on strings as well as numbers */
	case sub:		if (left.data_type == d_string){
				/* string stuff */
			}else{
				left_op  = get_op_string(left,address_reg,&next_address,left_op);
				right_op = get_op_string(right,next_address,&next_address,right_op);

				if (left.type != o_reg)
				{
					result.type = o_reg;
					result.data = 0;
					fprintf(object_file,"\tmove.%c\td%d,%s\n",instr_size,left.reg,left_op);
				};
				
				if (left.data_type == d_real)
					fprintf(object_file,"\tf%s.d\td%d,%s\n",instr_name[instr],left.reg,right_op);
				else
					fprintf(object_file,"\t%s.%c\td%d,%s\n",instr_name[instr],instr_size,left.reg,right_op);
			};
			break;		
	
	case and:
	case or:		/* these work on booleans and numbers */
	case xor:		left_op  = get_op_string(left,address_reg,&next_address,left_op);
			right_op = get_op_string(right,next_address,&next_address,right_op);
				
			if (left.type != o_reg)
			{
				result.type = o_reg;
				result.data = 0;
				fprintf(object_file,"\tmove.d\td%d,%s\n",left.reg,left_op);
			};

			fprintf(object_file,"\t%s.%c\td%d,%s\n",instr_name[instr],instr_size,left.reg,right_op);
			break;
	
	case multi:
	case modulo:		
	case divide:		/* pure numerics - both floats and ints */
			left_op  = get_op_string(left,address_reg,&next_address,left_op);
			right_op = get_op_string(right,next_address,&next_address,right_op);
				
			if (left.type != o_reg)
			{
				result.type = o_reg;
				result.data = 0;
				fprintf(object_file,"\tmove.%c\td%d,%s\n",instr_size,left.reg,left_op);
			};
			
			if (left.data_type == d_real)
				fprintf(object_file,"\tf%s.%c\td%d,%s\n",instr_name[instr],instr_size,left.reg,right_op);
			else
				fprintf(object_file,"\t%s.%c\td%d,%s\n",instr_name[instr],instr_size,left.reg,right_op);
			break;

	case store:	
	case load:		left_op  = get_op_string(left,address_reg,&next_address,left_op);
			right_op = get_op_string(right,next_address,&next_address,right_op);
			if (left.data_type == d_instance)
			{
				fprintf(object_file,"\tmove.d\td%d,%s\n",left.reg,left_op);
				fprintf(object_file,"\tmove.d\td%d,%s\n",right.reg,right_op);

				fprintf(object_file,"\tmove.d\ta30(d%d)+,a30(d%d)+\n",left.reg,right.reg);
				fprintf(object_file,"\tmove.d\ta30(d%d)+,a30(d%d)+\n",left.reg,right.reg);
				fprintf(object_file,"\tmove.d\ta30(d%d)+,a30(d%d)+\n",left.reg,right.reg);
			} else
				fprintf(object_file,"\tmove.%c\t%s,%s\n",instr_size,left_op,right_op);
			break;

	case subr:
	case endsubr:		/* the basic enter and leave functions */
			fprintf(object_file,"enter or leave here!!!\n");
			break;
	
	default:	yyerror("Invalid instruction found number %d. \n",instr);
	};


	free(left_op);
	free(right_op);
	return result;
}
