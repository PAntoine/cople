/* $Revision: 1.2 $
 *
 *		           Generate Intel Code
 *
 *	This function is part of the cople compiler. It controls the genration
 *	of the cople assembler. All the code is targetted for the NASM compiler
 *	as this runs on both Micro$oft and *nix platforms. The code is designed
 *	to be loaded by a COPLE type loader and not to run directly under these
 *	operating systems. The system code is designed for the COBOS OS.
 *
 *		Copyright (c) 1999 Peter Antoine.
 *
 */

#include	<stdlib.h>
#include	<stdio.h>
#include	"cople.h"
#include	"codetree.h"
#include	"intel.h"

int	max_save_space;
int	current_saved;
int	current_label;
int	click_count;
int	register_no;
int	es_dirty;
SEG_REGISTER	*seg_reg;
VIRT_REGISTER	*virt_reg;
REAL_REGISTER	*real_reg;
long	*save_space;

void	generate_intel_code(CLAUSE *clause, LEVEL_LNK *stack)
{
	extern int		max_memory_size, initial_size;
	extern int		version, release;
	extern PROCESSOR	target;
	extern FILE		*object_file;

	/* initialise the globals */

	current_label = 0;
	click_count = 0;
	register_no = 0;

	/* Need to intialise the register spaces - note that there are two
	 * sets of registers. This is to allow for register swapping and pushing
	 * as the small number of registers on the x86's plus some registers are
	 * needed for specific instructions.
	 */
	
	seg_reg  = calloc(3,sizeof(SEG_REGISTER));
	virt_reg = calloc(MAX_VIRTUAL_REGISTERS,sizeof(VIRT_REGISTER));
	real_reg = calloc(6,sizeof(REAL_REGISTER));
	save_space = calloc(MAX_VIRTUAL_REGISTERS,sizeof(long));

	max_save_space = 0;
	current_saved = 0;

	/* might as well start with the header information:
	 * The format is: 'cople' version_no,release_no and then the size of the data
	 * and the code. The last two are generated by the asembler.
	 */

	fprintf(object_file,"\tbits 32\n");
	fprintf(object_file,"\t%%include\t\"programmer_api.inc\"\n");
	fprintf(object_file,"\tdb\t\'cople\',%d,%d\n",version,release);
	fprintf(object_file,"\tdd\tcode_end-start,data_end-code_end,stack_size\n");
	
	fprintf(object_file,"start:\n");
	
	/* now genrate the program code. */
	gi_block_code(clause,stack,0);

	fprintf(object_file,"\tcall\tend_program:dword 0\n");

	/* now generate the whenever code */
	gi_when_code(stack);
	
	fprintf(object_file,"code_end:\n");

	/* now generate the data from the program */
	gi_generate_data();

	fprintf(object_file,"data_end:\tnop\n");

	/* lets set up the stack size */
	fprintf(object_file,"stack_size\tequ\t%d\n",stack->count);

	/* lets free up the register tables space */
	free(virt_reg);
	free(real_reg);
	free(save_space);
}
