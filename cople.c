/* $Revision: 1.2 $
 *
 *		COPLE Compiler
 *
 *		  Version 1.1
 *
 *	This is the main program for the COPLE compiler. This uses a YACC
 *	generated parser with a hand coded lex analyser. The code is then
 *	generated by the generate_code function. If the DOT option is set
 *	the generate code function will create a dot file that can be used
 *	to create a postscript file of the code structure.
 *
 *	$Log: cople.c,v $
 *	Revision 1.2  1999/11/07 10:36:53  devel
 *	Added the processor specific compiler stuff. Also added code to generate
 *	the INTEL (486) specific code for the NASM compiler. The system also now
 *	includes a dummy file that is points to the system functions. This file
 *	is not correct but lets the code test compile. This file needs to be
 *	created when the COBOS or COPLEVM programs are complete as these are the
 *	programmer API functions. Also there are some bug fixes. The langauge
 *	is now complete but not correct. That is for the next release.
 *
 *
 *		Author: 	Peter Antoine.
 *		Copyright:	1998-1999
 * 
 */

#include	<stdio.h>
#include	<string.h>
#include	<memory.h>
#include	<getopt.h>
#include	"cople.h"
#include	"codetree.h"
#include	"cople.tab.h"

/* GLOBALS needed by the functions that make up the parser
 * and are used by nearly all the parser functions.
 */

FILE	*input_file;
FILE	*dot_file;
FILE	*object_file;
CONSTANT	*tmp_const;
SYMBOL	*tmp_symbol;
PARAMETER	tp;
CLAUSE	*system_pnt;
CLAUSE	*user_pnt;
CLAUSE	*node_pnt;

CODE_TYPE	program_type;
LEVEL_LNK	*memory_list,*last_mem_lnk,*fix_up_list;
RANGE_FIXUP	*range_list;
HASH_TABLE	symbol_table;
CLAUSE	*current_block;
CLAUSE	*tree_root;
char	*prog_name;
int	max_memory_size;
int	initial_size;
char	*initial_space;
int	current_memory;

int	level_at;
int	lineno;
int	clause_num;
int	error;

int	label_number;
LEVEL_LNK	*label_list;

int	when_label;
int	current_when[NUM_EXCEPTIONS];
WHENEVER_LIST	*when_list;

PROCESSOR	target;
int	version,release;


int	main(int argc, char *argv[])
{
	int	failed,count,no_code=0,do_dot=0,quiet=0,help=0,verbose=0;
	int	found;
	char	c;
	char	*object_filename = NULL, *dot_filename = NULL;
	char	*name_tail = NULL;
	char	*prog_type[] = {"NONE","OBJECT","SYSTEM","APPLICATION"};

	/* initialise the globals */
	when_list	= 0;
	level_at	= 0;
	error	= 0;
	lineno          = 1;
	max_memory_size = 0;
	current_memory  = 0;
	label_number    = 0;
	initial_size    = 4 + (32*4);	/* 32 dwords the exception table then 4 bytes are the status bytes */
	initial_space   = NULL;
	when_list	= NULL;
	target	= __DEFAULT_PROC__;

	sscanf(__VERSION_NO__,"$%*s %d.%d",&version,&release);


	/* set up the when list */
	for (count=0; count<NUM_EXCEPTIONS;count++)
		current_when[count] = 0;	/* just making sure! */

	/* set up the memory thing */
	memory_list = (LEVEL_LNK*) calloc(1,sizeof(LEVEL_LNK));
	last_mem_lnk = memory_list;
	fix_up_list  = NULL;
	range_list   = NULL;

	/* lets use getopts to read the input line of the call.
	 * The following options are used.
	 *
	 * c 	 - compile only (no code or assembler is produced)
	 * d [file_name] - genrate dot file (optional file name)
	 * o file_name   - genrate object file with the given name.
	 * s	 - use the standard input for the file name.
	 * q	 - quiet - do not produce any noise.
	 * h	 - give a listing of this file.
	 */

	while( (c = getopt(argc,argv,"cd::o:qhvp:")) != -1 )
	{
		switch(c)
		{
		case 'c':	no_code = 1;
			break;
	
		case 'd':	do_dot = 1;
			if (optarg != NULL)
				dot_filename = optarg;
			break;

		case 'o':	object_filename = optarg;
			break;

		case 'q':	quiet = 1;
			break;
	
		case 'h':	help = 1;
			break;

		case 'v':	verbose = 1;
			break;
		
		case 'p':	found = 0;
			if (optarg != NULL)
				if (!strcmp(optarg,"486")){
					target = INTEL_486;
					found = 1;
				};

			if (!found)
				printf("Dont know that processor, using the default.\n");
			break;
		};
	};

	

	/* Pretty message time...
	 */

	if (verbose)
		printf("\n%s%d %s%d\n%s %s %s\n%s\n\n",
			" cople compiler - version ",version,
			"release ",release,
			" last built: ",__DATE__,__TIME__,
			" copyright (c) 1999 Peter Antoine.");
	else
		printf("cople complier %d.%d - copyright (c) 199 Peter Antoine.\n\n",version,release);
	
	if (help){
		printf("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s%s\n\n",
			"Usage: cople -c -d [dot_file] -o object_file -s -q -h source_file",
			"    c             - it will not generate any code output ",
			"    d [file_name] - gnerate a dot file, if the file name is geven use that name",
			"    o object_file - if the c option is not given - put object code in object_file",
			"    q             - dont genrate any error messages or version info",
			"    h             - this message.",
			"    v             - Verbose mode.",
			"    p PROCESSOR   - for system code the processor type default ",__DEFAULT_PROC__);
	 	exit(0);
	 }

	/* lets open the input file. Note the source file name is the first argument
	 * after the options that are given above.
	 */
	if (optind >= argc)
	{
		printf("Must supply a source file name.\n");
		exit(1);
	} else {
		name_tail = (char*) rindex(argv[optind],'.');
		if (strcmp(name_tail,".cople") != 0){
			printf("source name must end in \".cople\".\n");
			exit(1);
		}else{
			if (!(input_file = fopen(argv[optind],"r"))) {
				printf("failed to open %s \n",argv[optind]);
				return 1;
			}
		};
	};

	if (verbose)
		printf("Parsing source file: %s\n",argv[optind]);

	/* lets call the parser 
	 * **** JUST IN CASE YOU MISSED IT ****
	 */
	failed = yyparse();

	/* now generate the dot file */
	
	if (do_dot && !failed && !error)
	{
		if (dot_filename == NULL)
		{
			dot_filename = (char*) calloc(1,(name_tail - argv[optind])+5);
			memcpy(dot_filename,argv[optind],(int)(name_tail - argv[optind]));
			strcat(dot_filename,".dot");
		};

		if (!(dot_file = fopen(dot_filename,"w"))) {
			printf("failed to open %s \n",dot_filename);
			return 1;
		}

		fprintf(dot_file, "digraph %s{\n%s\nheader[label = \"{%s|name:%s }\"];\n%s\n",
			prog_name,
			"node [shape = record,height=.1,fontsize=10];",
			prog_type[program_type],
			prog_name,
			"subgraph cluster0{");
		
		gen_dot_block(tree_root);
		
		fprintf(dot_file,"\n}\n}\n");
	
		if (verbose)
			printf("Generating DOT file: %s\n",dot_filename);
	};
		
	/* now generate the object code */
	
	if (!no_code && !failed && !error)
	{
		if (object_filename == NULL)
		{
			object_filename = (char*) calloc(1,(name_tail - argv[optind])+5);
			memcpy(object_filename,argv[optind],(int)(name_tail - argv[optind]));
		
			switch(program_type)
			{
			case p_object:		strcat(object_filename,".cobj");
					break;
			case p_application:	strcat(object_filename,".capp");
					break;
			case p_system:		strcat(object_filename,".csys");
					break;
			};
		};

		if (!(object_file = fopen(object_filename,"wb"))) {
			printf("failed to open %s \n",object_filename);
			return 1;
		};

		/* call code genrate here! */
		generate_code(tree_root);
	
		if (verbose)
			printf("Generating object file: %s\n",object_filename);
	};
	
	printf("\n");
	return 0;
}

yyerror(char *s)
{
	printf("Line %d: %s\n",lineno,s);
	fflush(object_file);
	error = 1;
}

void	comp_error(int error_code, char *error_message)
{
	if (error_code == FATAL_ERROR)
		printf("FATAL ERROR: ");
	else if (error_code == FATAL_ERROR)
		printf("WARNING: ");
			
	printf("%s\n%s\n%s\n",error_message, "please contact the author with the error message", "and send a copy of the program.");

/*	if (error_code == FATAL_ERROR)
		clear_tree();*/

	exit(-1);
}
